Система запуска простая и не гибкая, ибо и не надо.  

Входной бинарный файл **всегда** должен называться input [связь с именем файла в simul.cpp, createbin].  
Входной файл с асемблерным кодом, чтобы удобнее было писать программы **всегда** должен называться code.asm [связь с именем файла в createbin]  
При большом желании или необходимости имена файлов можно параметризовать, для этого надо отредактировать то, что указано в квадратных скобках выше  

Весь вывод симулятора производится на файл stdout  
Исполняемый файл принимает два опциональных аргумента без лидирующих дефисов: "log" и "debug". Первый аргумент включает трейс "конвейера" в stdout, второй аргумент приводит к печати полного дампа задействованной в процессе работы программы памяти и к печати информации о полях входного бинарного файла (все тоже в stdout)  

###Сборка и запуск с готовым файлом input
```bash
{PROJ}$cd src  
{PROJ}/src$make && ./exec
```

###Сборка и запуск с готовым файлом input и всеми информационными сообщениями  
```bash
{PROJ}$cd src  
{PROJ}/src$make && ./exec log debug
```

Для удобства использования (и проверки) можно использовать скрипты ./createbin и ./custombin  
Внутри скрипта createbin в соответствующий секциях задаются информация для загрузчика, двухбайтовые поля-параметры. Чтобы изменить из значения, необходимо отредактировать сам скрипт, благо это не сложно  
Поле code_sz модифицировать нельзя, как и саму секцию кода. Они автоматически генерируются скриптом translate.py из ассемблерного файла code.asm  
Остальные секции и поля можно добавить как угодно.  

Скрипт custombin позволяет менять все секции файла вручную. Таким образом можно проверить случаи неправильно собранных инструкций, несоответствия рзаданного и реального размера секции кода в файле  

###Сборка и запуск с генерируемым файлом input  
Соответственно, запуск можно проводить так

```bash
{PROJ}$cd src  
{PROJ}/src$make && ./createbin && ./exec
```  

или так  

```bash
{PROJ}$cd src  
{PROJ}/src$make && ./custombin && ./exec
```  
